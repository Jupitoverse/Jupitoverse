<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroid & Comet Explorer - Test Version</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
        }
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
        }
        #canvas3d {
            width: 100%;
            height: 100vh;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 24px;
        }
        .error {
            color: #ff0000;
        }
        .success {
            color: #00ff00;
        }
    </style>
</head>
<body>
    <div id="status">
        <h3>Loading Status:</h3>
        <div id="statusLog"></div>
    </div>
    
    <div id="canvas3d">
        <div class="loading">
            <p id="loadingText">Initializing...</p>
        </div>
    </div>

    <script>
        const statusLog = document.getElementById('statusLog');
        const loadingText = document.getElementById('loadingText');
        
        function log(message, isError = false) {
            console.log(message);
            const p = document.createElement('p');
            p.textContent = message;
            p.className = isError ? 'error' : 'success';
            statusLog.appendChild(p);
        }

        log('Starting initialization...');
        loadingText.textContent = 'Loading Three.js...';

        // Load Three.js
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
        script.onload = function() {
            log('‚úì Three.js loaded successfully');
            loadingText.textContent = 'Three.js loaded. Creating scene...';
            setTimeout(initScene, 100);
        };
        script.onerror = function() {
            log('‚úó Failed to load Three.js from CDN', true);
            loadingText.textContent = 'Error: Could not load Three.js';
            loadingText.className = 'error';
        };
        document.head.appendChild(script);

        function initScene() {
            try {
                log('Checking THREE object...');
                if (typeof THREE === 'undefined') {
                    throw new Error('THREE is not defined');
                }
                log('‚úì THREE object is available');

                // Create scene
                log('Creating scene...');
                const scene = new THREE.Scene();
                log('‚úì Scene created');

                // Create camera
                log('Creating camera...');
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 5;
                log('‚úì Camera created');

                // Create renderer
                log('Creating renderer...');
                const canvas = document.getElementById('canvas3d');
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000011);
                
                // Clear canvas and add renderer
                canvas.innerHTML = '';
                canvas.appendChild(renderer.domElement);
                log('‚úì Renderer created and added to DOM');

                // Add ambient light
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                log('‚úì Ambient light added');

                // Add sun (yellow sphere)
                const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
                const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const sun = new THREE.Mesh(sunGeometry, sunMaterial);
                scene.add(sun);
                log('‚úì Sun added');

                // Add stars
                log('Adding stars...');
                const starsGeometry = new THREE.BufferGeometry();
                const starVertices = [];
                for (let i = 0; i < 5000; i++) {
                    const x = (Math.random() - 0.5) * 200;
                    const y = (Math.random() - 0.5) * 200;
                    const z = (Math.random() - 0.5) * 200;
                    starVertices.push(x, y, z);
                }
                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
                const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
                const stars = new THREE.Points(starsGeometry, starsMaterial);
                scene.add(stars);
                log('‚úì 5000 stars added');

                // Add Earth (blue sphere)
                const earthGeometry = new THREE.SphereGeometry(0.5, 32, 32);
                const earthMaterial = new THREE.MeshPhongMaterial({ color: 0x0077ff });
                const earth = new THREE.Mesh(earthGeometry, earthMaterial);
                earth.position.x = 4;
                scene.add(earth);
                log('‚úì Earth added');

                // Add Mars (red sphere)
                const marsGeometry = new THREE.SphereGeometry(0.3, 32, 32);
                const marsMaterial = new THREE.MeshPhongMaterial({ color: 0xff4444 });
                const mars = new THREE.Mesh(marsGeometry, marsMaterial);
                mars.position.x = -5;
                scene.add(mars);
                log('‚úì Mars added');

                // Add some asteroids
                for (let i = 0; i < 10; i++) {
                    const size = Math.random() * 0.2 + 0.1;
                    const astGeometry = new THREE.SphereGeometry(size, 16, 16);
                    const astMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                    const asteroid = new THREE.Mesh(astGeometry, astMaterial);
                    
                    const angle = (i / 10) * Math.PI * 2;
                    const distance = 6 + Math.random() * 2;
                    asteroid.position.x = Math.cos(angle) * distance;
                    asteroid.position.z = Math.sin(angle) * distance;
                    asteroid.position.y = (Math.random() - 0.5) * 2;
                    
                    scene.add(asteroid);
                }
                log('‚úì 10 asteroids added');

                log('‚úì‚úì‚úì Scene fully initialized! Starting animation...');

                // Animation loop
                let frame = 0;
                function animate() {
                    requestAnimationFrame(animate);
                    
                    frame++;
                    
                    // Rotate sun
                    sun.rotation.y += 0.005;
                    
                    // Orbit Earth
                    earth.position.x = Math.cos(frame * 0.01) * 4;
                    earth.position.z = Math.sin(frame * 0.01) * 4;
                    earth.rotation.y += 0.02;
                    
                    // Orbit Mars
                    mars.position.x = Math.cos(frame * 0.005) * 5;
                    mars.position.z = Math.sin(frame * 0.005) * 5;
                    mars.rotation.y += 0.015;
                    
                    // Rotate stars
                    stars.rotation.y += 0.0001;
                    
                    renderer.render(scene, camera);
                }
                
                animate();
                log('‚úì Animation started successfully!');

                // Handle window resize
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // Mouse control
                let isDragging = false;
                let previousMouse = { x: 0, y: 0 };
                
                canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    previousMouse = { x: e.clientX, y: e.clientY };
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - previousMouse.x;
                        const deltaY = e.clientY - previousMouse.y;
                        
                        camera.position.x += deltaX * 0.01;
                        camera.position.y -= deltaY * 0.01;
                        camera.lookAt(0, 0, 0);
                        
                        previousMouse = { x: e.clientX, y: e.clientY };
                    }
                });
                
                canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                });
                
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    camera.position.z += e.deltaY * 0.01;
                    camera.position.z = Math.max(3, Math.min(50, camera.position.z));
                });

                log('‚úì Mouse controls enabled');
                log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                log('üöÄ READY! Drag to rotate, scroll to zoom');
                
            } catch (error) {
                log('‚úó Error: ' + error.message, true);
                loadingText.textContent = 'Error: ' + error.message;
                loadingText.className = 'error';
            }
        }
    </script>
</body>
</html>





